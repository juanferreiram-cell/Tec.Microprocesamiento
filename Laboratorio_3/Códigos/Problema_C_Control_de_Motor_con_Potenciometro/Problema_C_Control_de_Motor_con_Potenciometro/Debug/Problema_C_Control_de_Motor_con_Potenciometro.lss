
Problema_C_Control_de_Motor_con_Potenciometro.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000023c  2**0
                  ALLOC, LOAD, DATA
  1 .text         00000080  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      0000002f  00000000  00000000  0000023c  2**0
                  CONTENTS, READONLY
  3 .stack.descriptors.hdr 0000000e  00000000  00000000  0000026b  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000060  00000000  00000000  00000279  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000c3b  00000000  00000000  000002d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000007a0  00000000  00000000  00000f14  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000037e  00000000  00000000  000016b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000a4  00000000  00000000  00001a34  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000022e  00000000  00000000  00001ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000012d  00000000  00000000  00001d06  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000050  00000000  00000000  00001e33  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000004  000001ba  000001ba  0000022e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001e84  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.iniciar_pwm 00000014  00000162  00000162  000001d6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.ajustar_pwm 0000000c  000001ae  000001ae  00000222  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.iniciar_motor 0000000e  00000176  00000176  000001ea  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.motor_derecha 0000000e  00000184  00000184  000001f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.motor_izquierda 0000000e  00000192  00000192  00000206  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.motor_parar 0000000e  000001a0  000001a0  00000214  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.iniciar_adc 00000024  00000128  00000128  0000019c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.leer_adc 00000032  000000f6  000000f6  0000016a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.main    00000076  00000080  00000080  000000f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.__dummy_fini 00000002  000001c2  000001c2  00000236  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.__dummy_funcs_on_exit 00000002  000001c4  000001c4  00000238  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.__dummy_simulator_exit 00000002  000001c6  000001c6  0000023a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.exit    00000016  0000014c  0000014c  000001c0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text._Exit   00000004  000001be  000001be  00000232  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
   8:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
   c:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  10:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  14:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  18:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  1c:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  20:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  24:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  28:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  2c:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  30:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  34:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  38:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  3c:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  40:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  44:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  48:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  4c:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  50:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  54:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  58:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  5c:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  60:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>
  64:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61
  74:	0e 94 40 00 	call	0x80	; 0x80 <_etext>
  78:	0c 94 a6 00 	jmp	0x14c	; 0x14c <exit>

0000007c <_exit>:
  7c:	f8 94       	cli

0000007e <__stop_program>:
  7e:	ff cf       	rjmp	.-2      	; 0x7e <__stop_program>

Disassembly of section .text:

000001ba <__bad_interrupt>:
 1ba:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.iniciar_pwm:

00000162 <iniciar_pwm>:
static const uint16_t TOLERANCIA = 15;
static const uint8_t PWM_MINIMO = 150;
static const uint8_t PWM_MAXIMO = 170;

void iniciar_pwm(void){
	DDRB |= (1 << PB1);
 162:	84 b1       	in	r24, 0x04	; 4
 164:	82 60       	ori	r24, 0x02	; 2
 166:	84 b9       	out	0x04, r24	; 4
	TCCR1A = (1 << COM1A1) | (1 << WGM10);
 168:	81 e8       	ldi	r24, 0x81	; 129
 16a:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f8080>
	TCCR1B = (1 << WGM12) | (1 << CS11);
 16e:	8a e0       	ldi	r24, 0x0A	; 10
 170:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
 174:	08 95       	ret

Disassembly of section .text.ajustar_pwm:

000001ae <ajustar_pwm>:
}

void ajustar_pwm(uint8_t valor){
	OCR1A = valor;
 1ae:	90 e0       	ldi	r25, 0x00	; 0
 1b0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 1b4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 1b8:	08 95       	ret

Disassembly of section .text.iniciar_motor:

00000176 <iniciar_motor>:
}

void iniciar_motor(void){
	DDRD |= (1 << IN1) | (1 << IN2);
 176:	8a b1       	in	r24, 0x0a	; 10
 178:	8c 60       	ori	r24, 0x0C	; 12
 17a:	8a b9       	out	0x0a, r24	; 10
	PORTD &= ~((1 << IN1) | (1 << IN2));
 17c:	8b b1       	in	r24, 0x0b	; 11
 17e:	83 7f       	andi	r24, 0xF3	; 243
 180:	8b b9       	out	0x0b, r24	; 11
 182:	08 95       	ret

Disassembly of section .text.motor_derecha:

00000184 <motor_derecha>:
}

void motor_derecha(void){
	PORTD |= (1 << IN1);
 184:	8b b1       	in	r24, 0x0b	; 11
 186:	84 60       	ori	r24, 0x04	; 4
 188:	8b b9       	out	0x0b, r24	; 11
	PORTD &= ~(1 << IN2);
 18a:	8b b1       	in	r24, 0x0b	; 11
 18c:	87 7f       	andi	r24, 0xF7	; 247
 18e:	8b b9       	out	0x0b, r24	; 11
 190:	08 95       	ret

Disassembly of section .text.motor_izquierda:

00000192 <motor_izquierda>:
}

void motor_izquierda(void){
	PORTD &= ~(1 << IN1);
 192:	8b b1       	in	r24, 0x0b	; 11
 194:	8b 7f       	andi	r24, 0xFB	; 251
 196:	8b b9       	out	0x0b, r24	; 11
	PORTD |= (1 << IN2);
 198:	8b b1       	in	r24, 0x0b	; 11
 19a:	88 60       	ori	r24, 0x08	; 8
 19c:	8b b9       	out	0x0b, r24	; 11
 19e:	08 95       	ret

Disassembly of section .text.motor_parar:

000001a0 <motor_parar>:
}

void motor_parar(void){
	PORTD &= ~((1 << IN1) | (1 << IN2));
 1a0:	8b b1       	in	r24, 0x0b	; 11
 1a2:	83 7f       	andi	r24, 0xF3	; 243
 1a4:	8b b9       	out	0x0b, r24	; 11
	ajustar_pwm(0);
 1a6:	80 e0       	ldi	r24, 0x00	; 0
 1a8:	0e 94 d7 00 	call	0x1ae	; 0x1ae <ajustar_pwm>
 1ac:	08 95       	ret

Disassembly of section .text.iniciar_adc:

00000128 <iniciar_adc>:
}

void iniciar_adc(void){
	ADMUX = (1 << REFS0);
 128:	80 e4       	ldi	r24, 0x40	; 64
 12a:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7f807c>
	ADCSRA = (1 << ADEN) | (1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0);
 12e:	ea e7       	ldi	r30, 0x7A	; 122
 130:	f0 e0       	ldi	r31, 0x00	; 0
 132:	87 e8       	ldi	r24, 0x87	; 135
 134:	80 83       	st	Z, r24
	DIDR0 = (1 << ADC3D) | (1 << ADC4D);
 136:	88 e1       	ldi	r24, 0x18	; 24
 138:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7f807e>
	ADCSRA |= (1 << ADSC);
 13c:	80 81       	ld	r24, Z
 13e:	80 64       	ori	r24, 0x40	; 64
 140:	80 83       	st	Z, r24
	while(ADCSRA & (1 << ADSC));
 142:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
 146:	86 fd       	sbrc	r24, 6
 148:	fc cf       	rjmp	.-8      	; 0x142 <iniciar_adc+0x1a>
}
 14a:	08 95       	ret

Disassembly of section .text.leer_adc:

000000f6 <leer_adc>:

uint16_t leer_adc(uint8_t canal){
	ADMUX = (ADMUX & 0xF0) | (canal & 0x0F);
  f6:	ec e7       	ldi	r30, 0x7C	; 124
  f8:	f0 e0       	ldi	r31, 0x00	; 0
  fa:	90 81       	ld	r25, Z
  fc:	90 7f       	andi	r25, 0xF0	; 240
  fe:	8f 70       	andi	r24, 0x0F	; 15
 100:	89 2b       	or	r24, r25
 102:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 104:	8a e1       	ldi	r24, 0x1A	; 26
 106:	8a 95       	dec	r24
 108:	f1 f7       	brne	.-4      	; 0x106 <leer_adc+0x10>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <leer_adc+0x16>
	_delay_us(5);
	ADCSRA |= (1 << ADSC);
 10c:	ea e7       	ldi	r30, 0x7A	; 122
 10e:	f0 e0       	ldi	r31, 0x00	; 0
 110:	80 81       	ld	r24, Z
 112:	80 64       	ori	r24, 0x40	; 64
 114:	80 83       	st	Z, r24
	while(ADCSRA & (1 << ADSC));
 116:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7f807a>
 11a:	86 fd       	sbrc	r24, 6
 11c:	fc cf       	rjmp	.-8      	; 0x116 <leer_adc+0x20>
	return ADC;
 11e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7f8078>
 122:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f8079>
}
 126:	08 95       	ret

Disassembly of section .text.main:

00000080 <main>:

int main(void){
	iniciar_adc();
  80:	0e 94 94 00 	call	0x128	; 0x128 <iniciar_adc>
	iniciar_motor();
  84:	0e 94 bb 00 	call	0x176	; 0x176 <iniciar_motor>
	iniciar_pwm();
  88:	0e 94 b1 00 	call	0x162	; 0x162 <iniciar_pwm>
	
	while(1){
		uint16_t referencia = leer_adc(3);
  8c:	83 e0       	ldi	r24, 0x03	; 3
  8e:	0e 94 7b 00 	call	0xf6	; 0xf6 <leer_adc>
  92:	ec 01       	movw	r28, r24
		uint16_t posicion = leer_adc(4);
  94:	84 e0       	ldi	r24, 0x04	; 4
  96:	0e 94 7b 00 	call	0xf6	; 0xf6 <leer_adc>
		int16_t error = (int16_t)referencia - (int16_t)posicion;
  9a:	c8 1b       	sub	r28, r24
  9c:	d9 0b       	sbc	r29, r25
		
		uint8_t pwm_salida = 0;
		
		if (error > -((int16_t)TOLERANCIA) && error < (int16_t)TOLERANCIA){
  9e:	ce 01       	movw	r24, r28
  a0:	0e 96       	adiw	r24, 0x0e	; 14
  a2:	4d 97       	sbiw	r24, 0x1d	; 29
  a4:	18 f4       	brcc	.+6      	; 0xac <main+0x2c>
			motor_parar();
  a6:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <motor_parar>
  aa:	1b c0       	rjmp	.+54     	; 0xe2 <main+0x62>
			pwm_salida = 0;
			} else {
			if (error > 0){
  ac:	1c 16       	cp	r1, r28
  ae:	1d 06       	cpc	r1, r29
  b0:	1c f4       	brge	.+6      	; 0xb8 <main+0x38>
				motor_izquierda();
  b2:	0e 94 c9 00 	call	0x192	; 0x192 <motor_izquierda>
  b6:	02 c0       	rjmp	.+4      	; 0xbc <main+0x3c>
				} else {
				motor_derecha();
  b8:	0e 94 c2 00 	call	0x184	; 0x184 <motor_derecha>
			}
			
			uint16_t magnitud = (error < 0) ? (uint16_t)(-error) : (uint16_t)error;
  bc:	ce 01       	movw	r24, r28
  be:	dd 23       	and	r29, r29
  c0:	24 f4       	brge	.+8      	; 0xca <main+0x4a>
  c2:	88 27       	eor	r24, r24
  c4:	99 27       	eor	r25, r25
  c6:	8c 1b       	sub	r24, r28
  c8:	9d 0b       	sbc	r25, r29
			uint16_t duty = magnitud;
			
			if (duty < PWM_MINIMO) duty = PWM_MINIMO;
  ca:	86 39       	cpi	r24, 0x96	; 150
  cc:	91 05       	cpc	r25, r1
  ce:	10 f4       	brcc	.+4      	; 0xd4 <main+0x54>
  d0:	86 e9       	ldi	r24, 0x96	; 150
  d2:	90 e0       	ldi	r25, 0x00	; 0
			if (duty > PWM_MAXIMO) duty = PWM_MAXIMO;
  d4:	8b 3a       	cpi	r24, 0xAB	; 171
  d6:	91 05       	cpc	r25, r1
  d8:	10 f0       	brcs	.+4      	; 0xde <main+0x5e>
  da:	8a ea       	ldi	r24, 0xAA	; 170
  dc:	90 e0       	ldi	r25, 0x00	; 0
			
			pwm_salida = (uint8_t)duty;
			ajustar_pwm(pwm_salida);
  de:	0e 94 d7 00 	call	0x1ae	; 0x1ae <ajustar_pwm>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  e2:	2f ef       	ldi	r18, 0xFF	; 255
  e4:	80 e7       	ldi	r24, 0x70	; 112
  e6:	92 e0       	ldi	r25, 0x02	; 2
  e8:	21 50       	subi	r18, 0x01	; 1
  ea:	80 40       	sbci	r24, 0x00	; 0
  ec:	90 40       	sbci	r25, 0x00	; 0
  ee:	e1 f7       	brne	.-8      	; 0xe8 <main+0x68>
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <main+0x72>
  f2:	00 00       	nop
  f4:	cb cf       	rjmp	.-106    	; 0x8c <main+0xc>

Disassembly of section .text.__dummy_fini:

000001c2 <_fini>:
 1c2:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

000001c4 <__funcs_on_exit>:
 1c4:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

000001c6 <__simulator_exit>:
 1c6:	08 95       	ret

Disassembly of section .text.exit:

0000014c <exit>:
 14c:	ec 01       	movw	r28, r24
 14e:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <__funcs_on_exit>
 152:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <_fini>
 156:	ce 01       	movw	r24, r28
 158:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <__simulator_exit>
 15c:	ce 01       	movw	r24, r28
 15e:	0e 94 df 00 	call	0x1be	; 0x1be <_Exit>

Disassembly of section .text._Exit:

000001be <_Exit>:
 1be:	0e 94 3e 00 	call	0x7c	; 0x7c <_exit>
